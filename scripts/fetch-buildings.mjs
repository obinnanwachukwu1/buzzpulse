#!/usr/bin/env node
// Fetch OSM building polygons within the campus zones and generate:
// - app/assets/buildings.json (FeatureCollection with {id,name} per building)
// - worker/src/locations.ts (id -> { lat, lng, name }) using polygon centroids

import fs from 'fs/promises';
import path from 'path';
import osmtogeojson from 'osmtogeojson';
import fetch from 'node-fetch';

const root = path.resolve(process.cwd(), '..');
const campusPath = path.join(root, 'app/assets/masks/campus.json');
const outBuildingsPath = path.join(root, 'app/assets/buildings.json');
const workerLocsPath = path.join(root, 'worker/src/locations.ts');

function toPolyString(ring) {
  // ring: [ [lng,lat], ... ] => "lat lon lat lon ..."
  return ring.map(([lng, lat]) => `${lat} ${lng}`).join(' ');
}

function campusRings(geo) {
  const features = geo.type === 'FeatureCollection' ? geo.features : [geo];
  const rings = [];
  for (const f of features) {
    const g = f.geometry ?? f;
    if (!g) continue;
    if (g.type === 'Polygon') {
      if (g.coordinates[0]) rings.push(g.coordinates[0]);
    } else if (g.type === 'MultiPolygon') {
      for (const poly of g.coordinates) if (poly[0]) rings.push(poly[0]);
    }
  }
  return rings;
}

function overpassQueryForRing(ring) {
  const poly = toPolyString(ring);
  return `(
    way["building"](poly:"${poly}");
    relation["building"](poly:"${poly}");
  );`;
}

function slugify(s) {
  return String(s)
    .toLowerCase()
    .normalize('NFKD')
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-+|-+$/g, '')
    .slice(0, 64);
}

function centroidOfPolygon(coords) {
  // Simple average of vertices; ok for small campus-scale polygons
  let sx = 0, sy = 0;
  for (const [lng, lat] of coords) { sx += lng; sy += lat; }
  const n = coords.length || 1;
  return { lat: sy / n, lng: sx / n };
}

function centroid(feature) {
  const g = feature.geometry;
  if (g.type === 'Polygon') {
    return centroidOfPolygon(g.coordinates[0]);
  }
  if (g.type === 'MultiPolygon') {
    return centroidOfPolygon(g.coordinates[0][0]);
  }
  return { lat: 0, lng: 0 };
}

async function main() {
  const campus = JSON.parse(await fs.readFile(campusPath, 'utf8'));
  const rings = campusRings(campus);
  if (!rings.length) {
    console.error('No campus rings found in', campusPath);
    process.exit(1);
  }

  const body = `
  [out:json][timeout:180];
  ${rings.map(overpassQueryForRing).join('\n')}
  out body; >; out skel qt;`;

  console.log('Querying Overpass with', rings.length, 'ring(s)â€¦');
  const res = await fetch('https://overpass-api.de/api/interpreter', {
    method: 'POST',
    headers: { 'content-type': 'application/x-www-form-urlencoded' },
    body: new URLSearchParams({ data: body }),
  });
  if (!res.ok) {
    console.error('Overpass error:', res.status, await res.text());
    process.exit(2);
  }
  const osm = await res.json();
  const gj = osmtogeojson(osm);

  // Keep only polygonal buildings
  const features = (gj.features || []).filter(f => ['Polygon','MultiPolygon'].includes(f.geometry?.type));
  console.log('Buildings (raw):', features.length);

  // Normalize properties: id (slug), name
  const seen = new Set();
  const norm = features.map((f) => {
    const tags = f.properties?.tags || {};
    const name = tags.name || tags['addr:housename'] || `Building ${f.id}`;
    let id = tags.ref || name;
    if (!id || id === name) id = `osm-${f.id}`;
    id = slugify(id);
    if (seen.has(id)) id = slugify(`${id}-${f.id}`);
    seen.add(id);
    return { type: 'Feature', properties: { id, name }, geometry: f.geometry };
  });

  const fc = { type: 'FeatureCollection', features: norm };
  await fs.writeFile(outBuildingsPath, JSON.stringify(fc, null, 2));
  console.log('Wrote', outBuildingsPath, 'with', norm.length, 'buildings');

  // Generate worker locations map
  const lines = [
    `// Auto-generated by scripts/fetch-buildings.mjs`,
    `// id -> { lat, lng, name }`,
    `export const BUILDINGS: Record<string, { lat: number; lng: number; name: string }> = {`,
  ];
  for (const f of norm) {
    const c = centroid(f);
    const id = f.properties.id;
    const name = JSON.stringify(f.properties.name);
    lines.push(`  "${id}": { lat: ${c.lat.toFixed(6)}, lng: ${c.lng.toFixed(6)}, name: ${name} },`);
  }
  lines.push('};');
  await fs.writeFile(workerLocsPath, lines.join('\n'));
  console.log('Wrote', workerLocsPath);
}

main().catch((e) => { console.error(e); process.exit(1); });
